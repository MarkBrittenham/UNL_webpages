<HTML>










































<center>Math 445 Number Theory</center><br>
<p>
<p><br>

<center>Introduction/Review of concepts from abstract algebra</center><br>
<p>
<p><br><p><br>

An integer p is <i>prime</i> if whenever p = ab with a,b <font face="symbol">Î</font
> \Bbb Z, either a = <font face="symbol">±</font
>n or b = <font face="symbol">±</font
>n .
<p>
[For sanity's sake, we will take the position that primes should 
<U>also</U> be  <font face="symbol">³</font
> 2 .]
<p>

<b>Fundamental Theorem of Arithmetic:</b> Every integer n <font face="symbol">³</font
> 2 can be expressed as a product of primes; n = p<sub>1</sub>&#183;<font face="symbol">¼</font
>&#183;p<sub>k</sub> .
<p>

If we insist that the primes are written in increasing order, p<sub>1</sub> <font face="symbol">£</font
> <font face="symbol">¼</font
> <font face="symbol">£</font
> p<sub>k</sub>, then this
representation is <i>unique</i>. 
<p>
<p><br><p><br>
<b>The Division Algorithm:</b> For any integers n  <font face="symbol">³</font
> 0 and m <font face="symbol"> &gt; </font
> 0, there are <i>unique</i>
integers q and r with n = mq+r and 0 <font face="symbol">£</font
> r <font face="symbol">£</font
> m-1 .
<p>

[Note: this is also true for any integers n,m with m <font face="symbol">¹</font
> 0, although you need to replace ``m-1''
with ``<font face="symbol">|</font
>m-1<font face="symbol">|</font
>'' .]
<p>

The basic idea: keep repeatedly subtracting m from n until what's left is less than m.
<p>
<p><br><p><br>
Notation: b<font face="symbol">|</font
>a = ``b divides a'' = ``b is a divisor of a'' = ``a is a multiple of b'', 
means a = bk for some integer k .
<p>

If b<font face="symbol">|</font
>a and a <font face="symbol">¹</font
> 0, then <font face="symbol">|</font
>b<font face="symbol">|</font
> <font face="symbol">£</font
> <font face="symbol">|</font
>a<font face="symbol">|</font
> .
<p>

If a<font face="symbol">|</font
>b and b<font face="symbol">|</font
>c, then a<font face="symbol">|</font
>c
<p>

If a<font face="symbol">|</font
>c and b<font face="symbol">|</font
>d, then ab<font face="symbol">|</font
>cd
<p>

If p is prime and p<font face="symbol">|</font
>ab, then either p<font face="symbol">|</font
>a or p<font face="symbol">|</font
>b
<p>
<p><br><p><br>
Notation: (a,b) = gcd(a,b) = greatest common divisor of a and b
<p>

Different, equivalent, formulations for d = (a,b) :
<p>

(1) d<font face="symbol">|</font
>a and d<font face="symbol">|</font
>b, and if c<font face="symbol">|</font
>a and c<font face="symbol">|</font
>b, then c <font face="symbol">£</font
> d .
<p>

(2) d is the smallest <i>positive</i> number that can be written as d = ax+by with a,b <font face="symbol">Î</font
> \Bbb Z .
<p>

(3) d<font face="symbol">|</font
>a and d<font face="symbol">|</font
>b, and if c<font face="symbol">|</font
>a and c<font face="symbol">|</font
>b, then c<font face="symbol">|</font
>d .
<p>

(4) d is the <i>only</i> divisor of a and b that can be expressed as d = ax+by with a,b <font face="symbol">Î</font
> \Bbb Z .
<p>

If c<font face="symbol">|</font
>a and c<font face="symbol">|</font
>b, then c<font face="symbol">|</font
>(a,b)
<p>

If c<font face="symbol">|</font
>ab and (c,a) = 1, then c<font face="symbol">|</font
>b
<p>

If a<font face="symbol">|</font
>c and b<font face="symbol">|</font
>c, and (a,b) = 1, then ab<font face="symbol">|</font
>c
<p>

If a = bq+r, then (a,b) = (b,r)
<p>

<b>Euclidean Algorithm:</b> This last fact gives us a way to compute (a,b), using the division algorithm:
<p>

Starting with a <font face="symbol"> &gt; </font
>b, compute a = bq<sub>1</sub>+r<sub>1</sub>, so (a,b) = (b,r<sub>1</sub>).
Then compute b = r<sub>1</sub>q<sub>2</sub>+r<sub>2</sub>, and repeat: r<sub>i-1</sub> = r<sub>i</sub>q<sub>i+1</sub> +r<sub>i+1</sub> .
Continue until r<sub>n+1</sub> = 0, then 
(a,b) = (b,r<sub>1</sub>) = (r<sub>1</sub>,r<sub>2</sub>) = <font face="symbol">¼</font
> = (r<sub>n</sub>,r<sub>n+1</sub>) = (r<sub>n</sub>,0) = r<sub>n</sub> .
<p>

Since b <font face="symbol"> &gt; </font
> r<sub>1</sub> <font face="symbol"> &gt; </font
> r<sub>2</sub> <font face="symbol"> &gt; </font
> r<sub>3</sub> <font face="symbol"> &gt; </font
> <font face="symbol">¼</font
> , this process must end, by well-orderedrness.
<p>

We can reverse these calculations to recover (a,b) = ax+by, by rewriting each equation in our
algorithm as r<sub>i+1</sub> = r<sub>i-1</sub>-r<sub>i</sub>q<sub>i+1</sub>, and then repeatedly substituting the higher equations into the 
lowest one, in turn, working up through the list of equations.
<p>

<p><br><p><br>
<b>Congruence modulo n :</b> Notation: a <font face="symbol">º</font
> b (mod n)  (also written a\medspace \underset n<font face="symbol">®</font
>  <font face="symbol">º</font
>  \medspaceb) means n<font face="symbol">|</font
>(b-a)
<p>

Equivalently: the division algorithm will give the same remainder for a and b when you divide by n
<p>

Congruence mod n is an <i>equivalence relation</i>
<p>

The <i>congruence class</i> of a mod n is the collection of all integers congruent mod n to a:
<p>

[a]<sub>n</sub> = {b <font face="symbol">Î</font
> \Bbb Z : a\medspace \underset n<font face="symbol">®</font
>  <font face="symbol">º</font
>  \medspaceb} = {b <font face="symbol">Î</font
> \Bbb Z : n<font face="symbol">|</font
>(b-a)}
<p>
<p><br><p><br>
<b>Fermat's Little Theorem.</b> If p is prime and (a,p) = 1, then a<sup>p-1</sup> \medspace \underset p<font face="symbol">®</font
>  <font face="symbol">º</font
>  \medspace1
<p>

Because: (a&#183;1)(a&#183;2)(a&#183;3)<font face="symbol">¼</font
>(a&#183;(p-1)) \medspace \underset p<font face="symbol">®</font
>  <font face="symbol">º</font
>  \medspace 1&#183;2&#183;3<font face="symbol">¼</font
>(p-1) , and 
(1&#183;2&#183;3<font face="symbol">¼</font
>(p-1),p) = 1 . Same idea, looking at the a's between 1 and n-1 that are 
relatively prime to n (and letting <font face="symbol">f</font
>(n) be the number of them), gives
<p>

If (a,n) = 1, then a<sup><font face="symbol">f</font
>(n)</sup> \medspace \underset n<font face="symbol">®</font
>  <font face="symbol">º</font
>  \medspace1 .
<p>

If the prime factorization of n is p<sub>1</sub><sup><font face="symbol">a</font
><sub>1</sub></sup><font face="symbol">¼</font
>p<sub>k</sub><sup><font face="symbol">a</font
><sub>k</sub></sup>, then <font face="symbol">f</font
>(n) = [p<sub>1</sub><sup><font face="symbol">a</font
><sub>1</sub></sup>(p<sub>1</sub>-1)]<font face="symbol">¼</font
>[p<sub>k</sub><sup><font face="symbol">a</font
><sub>k</sub></sup>(p<sub>k</sub>-1)]
<p>
<p><br><p><br>
The integers \Bbb Z, the integers mod n \Bbb Z<sub>n</sub>, the real numbers \Bbb R, the complex numbers
\Bbb C are all <i>rings</i>.
<p>

A <i>homomorphism</i> is a function <font face="symbol">f</font
>:R<font face="symbol">®</font
> S from a ring R to a ring S satisfying:
<p>
for any r,r<sup><font face="symbol">¢</font
></sup> <font face="symbol">Î</font
> R , <font face="symbol">f</font
>(r+r<sup><font face="symbol">¢</font
></sup>) = <font face="symbol">f</font
>(r) + <font face="symbol">f</font
>(r<sup><font face="symbol">¢</font
></sup>) and <font face="symbol">f</font
>(r&#183;r<sup><font face="symbol">¢</font
></sup>) = <font face="symbol">f</font
>(r) &#183;<font face="symbol">f</font
>(r<sup><font face="symbol">¢</font
></sup>) .
<p>
The basic idea is that it is a function that ``behaves well'' with respect to addition and multiplication.
<p>
An <i>isomorphism</i> is a homomorphism that is both one-to-one and onto. If there is an isomorphism from R to S, we say
that R and S are <i>isomorphic</i>, and write R <font face="symbol">@</font
> S . 
<p>
<p><br><p><br>
Example: if (m,n) = 1, then \Bbb Z<sub>mn</sub> <font face="symbol">@</font
> \Bbb Z<sub>m</sub>&times;\Bbb Z<sub>n</sub> . The isomorphism is given by
<p>
<font face="symbol">f</font
>([x]<sub>mn</sub>) = ([x]<sub>m</sub>,[x]<sub>n</sub>)
<p>
The main ingredients in the proof:
<p>

If <font face="symbol">f</font
>: R<font face="symbol">®</font
> S and <font face="symbol">y</font
>: R<font face="symbol">®</font
> T are ring homomorphisms, then the function
<font face="symbol">w</font
>: R <font face="symbol">®</font
> S&times;T given by <font face="symbol">w</font
>(r) = (<font face="symbol">f</font
>(r),<font face="symbol">y</font
>(r)) is also a homomorphism.
<p>
If m<font face="symbol">|</font
>n, then the function <font face="symbol">f</font
>: \Bbb Z<sub>n</sub><font face="symbol">®</font
> \Bbb Z<sub>m</sub> given by <font face="symbol">f</font
>([x]<sub>n</sub>) = [x]<sub>m</sub> is a homomorphism.
<p>

Together, these give that the function we want above is a homomorphism. The fact that (m,n) = 1 implies that <font face="symbol">f</font
> is 
one-to-one; then the Pigeonhole Principle implies that it is also onto!
<p>
The above isomorphism and induction imply that if n<sub>1</sub>,<font face="symbol">¼</font
>n<sub>k</sub> are <i>pairwise relatively prime</i> (i.e., 
if i <font face="symbol">¹</font
> j then (n<sub>i</sub>,n<sub>j</sub>) = 1), then 
<p>

\Bbb Z<sub>n<sub>1</sub><font face="symbol">¼</font
>n<sub>k</sub></sub>  <font face="symbol">@</font
>  \Bbb Z<sub>n<sub>1</sub></sub>&times;<font face="symbol">¼</font
>&times;\Bbb Z<sub>n<sub>k</sub></sub> . This implies:
<p>

<b>The Chinese Remainder Theorem:</b> If n<sub>1</sub>,<font face="symbol">¼</font
>n<sub>k</sub> are pairwise relatively prime, then for any a<sub>1</sub>,<font face="symbol">¼</font
>a<sub>k</sub> <font face="symbol">Î</font
> \Bbb N
the system of equations 
<p>

x <font face="symbol">º</font
> a<sub>i</sub> (mod n<sub>i</sub>), i = 1,<font face="symbol">¼</font
>k
<p>

has a solution, and any two solutions are congruent modulo n<sub>1</sub><font face="symbol">¼</font
>n<sub>k</sub> .
<p>

A solution can be found by (inductively) replacing a pair of equations x <font face="symbol">º</font
> a (mod n) , x <font face="symbol">º</font
> b (mod m), with a
single equation x <font face="symbol">º</font
> c (mod nm), by solving the equation a+nk = x = b+mj for k and j, using the Euclidean Algorithm.
<p>










<p><hr><small>File translated from T<sub>E</sub>X by T<sub>T</sub>H, version 0.9.</small>
</HTML>